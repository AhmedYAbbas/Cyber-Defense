using System;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;


public class MalwareShootingSystem : MonoBehaviour
{
    [SerializeField] private MalwareData _malwareData;
    private List<GameObject> _towers = new List<GameObject>();
    private GameObject _currentTarget;

    private float _attackCountdown;
    private float _attackSpeed;
    private int _damage;
    private float _range;
    private SphereCollider _targetingCollider;
    private Animator _animator;

    private ObjectPool _projectilePool;
    [SerializeField] private PoolableObject _malwareProjectilePrefab;

    private void Start()
    {
        _animator = GetComponentInParent<Animator>();
        _projectilePool = ObjectPool.CreatInstance(_malwareProjectilePrefab, 20);
        _attackSpeed = _malwareData.FireRate;
        _damage = _malwareData.AttackDamage;
        _range = _malwareData.Range;
        _targetingCollider = gameObject.GetComponent<SphereCollider>();
        _targetingCollider.radius = _range;
    }

    private void OnDisable()
    {
        _towers.Clear();
    }

    private void Update()
    {
        GettingTheClosestTower();
        CalculateShootingRate();
        //print(_towers.Count);
    }
    private void GettingTheClosestTower()
    {
        float closestTower = 0;
        GameObject tempEnemy = null;
        for (int i = 0; i < _towers.Count; i++)
        {
            print("loop in " + i);
            if (_towers[i] == null)
            {
                _towers.RemoveAt(i);
                continue;
            }
            //float enemyDistanceFromTower = Vector3.Distance(transform.position, _enemies[i].transform.position);
            //var test = _towers[i].GetComponent<Tower>();
            //float currentDangerousLevel = (-i+1) * 0.6f + (0.2f * test.MovementSpeed);
            float currentClosestTower = Vector3.Distance(transform.position, _towers[i].transform.position);
            if (closestTower < currentClosestTower)
            {
                closestTower = currentClosestTower;
                tempEnemy = _towers[i];
            }
        }
        _currentTarget = tempEnemy;
    }
    private void CalculateShootingRate()
    {
        if (_attackCountdown <= 0)
        {
            Shoot();
            _attackCountdown = 1f / _attackSpeed;
        }

        _attackCountdown -= Time.deltaTime;
    }
    private void Shoot()
    {
        print("trying to shoot");
        if (_towers.Count > 0)
        {
            //GameObject projectile = Instantiate(_projectilePrefab, transform.position , Quaternion.identity);
            var projectile = _projectilePool.GetObject();
            projectile.transform.position = transform.position;
            projectile.GetComponent<MalwareProjectile>().GetTarget(_currentTarget.transform, _damage);
            _animator?.SetTrigger("IsAttacking");
        }
    }
    void OnTriggerEnter(Collider collision)
    {
        if (collision.CompareTag("Tower") || collision.CompareTag("Base"))
        {
            _towers.Add(collision.gameObject);
            print("Tower foundddddddddddddddddd");
        }
    }
    void OnTriggerExit(Collider collision)
    {
        if (collision.CompareTag("Tower") || collision.CompareTag("Base"))
        {
            _towers.Remove(collision.gameObject);
            print("Tower Gryyyyyyyyyyyy");

        }
    }
}
