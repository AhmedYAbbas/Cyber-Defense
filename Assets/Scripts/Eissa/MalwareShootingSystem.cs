using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;


public class MalwareShootingSystem : MonoBehaviour
{
    
    #region Targets Variables

    private List<GameObject> _towers = new List<GameObject>();
    private GameObject _currentTarget;
    private GameObject _baseTarget;

    #endregion

    #region malware attribates Variables
    
    [FormerlySerializedAs("_malwareData")] [SerializeField] private MalwareData malwareData;
    private float _attackCountdown;
    private float _attackSpeed;
    private int _damage;
    private float _range;
    private SphereCollider _targetingCollider;
    private Animator _animator;

    #endregion

    #region Object pooling Variables

    [SerializeField] private PoolableObject _malwareProjectilePrefab;
    private ObjectPool _projectilePool;

    #endregion

    private void Start()
    {
        _animator = GetComponentInParent<Animator>();
        
        _projectilePool = ObjectPool.CreatInstance(_malwareProjectilePrefab,10);
        
        _attackSpeed = malwareData.FireRate;
        _damage = malwareData.AttackDamage;
        
        _range = malwareData.Range;
        _targetingCollider = gameObject.GetComponent<SphereCollider>();
        _targetingCollider.radius = _range;
    }
    private void OnDisable()
    {
        _towers.Clear();
    }

    private void Update()
    {
        GettingTheClosestTower();
        CalculateShootingRate();
    }
    private void GettingTheClosestTower()
    {
        if (_baseTarget == null)
        {
            float closestTower = 0;
            GameObject tempEnemy = null;
            for (int i = 0; i < _towers.Count; i++)
            {
                if (_towers[i] == null)
                {
                    _towers.RemoveAt(i);
                    continue;
                }
                Vector3 distanceVector = transform.position - _towers[i].transform.position;
                float currentClosestTower = Vector3.SqrMagnitude(distanceVector);
                if (closestTower < currentClosestTower)
                {
                    closestTower = currentClosestTower;
                    tempEnemy = _towers[i];
                }
            }
            _currentTarget = tempEnemy;
        }
        else
        {
            _currentTarget = _baseTarget;
        }
    }
    private void CalculateShootingRate()
    {
        if (_attackCountdown <= 0)
        {
            Shoot();
            _attackCountdown = 1f / _attackSpeed;
        }
        _attackCountdown -= Time.deltaTime;
    }
    private void Shoot()
    {
        if (_baseTarget != null || _towers.Count > 0)
        {
            var projectile = _projectilePool.GetObject();
            projectile.transform.position = transform.position;
            projectile.GetComponent<MalwareProjectile>().GetTarget(_currentTarget.transform, _damage);;
            _animator?.SetTrigger("IsAttacking");
        }
    }
    void OnTriggerEnter(Collider collision)
    {
        if (collision.CompareTag("Tower"))
        {
            _towers.Add(collision.gameObject);
        }

        else if (collision.CompareTag("Base"))
        {
            _baseTarget = collision.gameObject;
        }
    }
    void OnTriggerExit(Collider collision)
    {
        if (collision.CompareTag("Tower"))
        {
            _towers.Remove(collision.gameObject);
        }
        else if (collision.CompareTag("Base"))
        {
            _baseTarget = null;
        }
    }
}
