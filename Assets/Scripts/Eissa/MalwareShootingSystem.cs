using System;
using System.Collections;
using System.Collections.Generic;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Serialization;


public class MalwareShootingSystem : MonoBehaviour
{
    
    #region Targets Variables

    private List<GameObject> _towers = new List<GameObject>();
    private GameObject _currentTarget;
    private GameObject _baseTarget;

    #endregion

    #region malware attribates Variables
    
    [FormerlySerializedAs("_malwareData")] [SerializeField] private MalwareData malwareData;
    private float _attackCountdown;
    private float _attackSpeed;
    private int _damage;
    private int _damageScaling;
    private float _range;
    private SphereCollider _targetingCollider;
    private Animator _animator;
    private Coroutine _increaseDamageCoroutine;

    #endregion

    #region Object pooling Variables

    [SerializeField] private PoolableObject _malwareProjectilePrefab;
    private ObjectPool _projectilePool;

    #endregion

    private void Start()
    {
        _animator = GetComponentInParent<Animator>();
        
        _projectilePool = ObjectPool.CreatInstance(_malwareProjectilePrefab,10);
        
        _attackSpeed = malwareData.FireRate;
        _damage = malwareData.AttackDamage;
        
        _range = malwareData.Range;
        _targetingCollider = gameObject.GetComponent<SphereCollider>();
        _targetingCollider.radius = _range;
    }
    private void OnDisable()
    {
        _towers.Clear();
        _baseTarget = null;
        if (_increaseDamageCoroutine != null)
        {
            StopCoroutine(_increaseDamageCoroutine);
            _increaseDamageCoroutine = null;
        }
        _damageScaling = 0;
    }

    private void OnEnable()
    {
        if (_increaseDamageCoroutine == null)
        {
            _increaseDamageCoroutine = StartCoroutine(IncreaseDamageScalingPeriodically(1.5f));
        }
        UpdateMalwareDamage();
    }

    private void Update()
    {
        GettingTheClosestTower();
        CalculateShootingRate();
    }
    
    private void GettingTheClosestTower()
    {
        if (_baseTarget == null)
        {
            float closestTower = 0;
            GameObject tempEnemy = null;
            for (int i = 0; i < _towers.Count; i++)
            {
                if (_towers[i] == null)
                {
                    _towers.RemoveAt(i);
                    continue;
                }
                Vector3 distanceVector = transform.position - _towers[i].transform.position;
                float currentClosestTower = Vector3.SqrMagnitude(distanceVector);
                if (closestTower < currentClosestTower)
                {
                    closestTower = currentClosestTower;
                    tempEnemy = _towers[i];
                }
            }
            _currentTarget = tempEnemy;
        }
        else
        {
            _currentTarget = _baseTarget;
        }
    }
    private void CalculateShootingRate()
    {
        if (_attackCountdown <= 0)
        {
            Shoot();
            _attackCountdown = 1f / _attackSpeed;
        }
        _attackCountdown -= Time.deltaTime;
    }
    private void Shoot()
    {
        if (_baseTarget != null || _towers.Count > 0)
        {
            var projectile = _projectilePool.GetObject() as MalwareProjectile;
            projectile.transform.position = transform.position;
            projectile.GetTarget(_currentTarget.transform, _damage);
            _animator?.SetTrigger("IsAttacking");
        }
    }
    void OnTriggerEnter(Collider collision)
    {
        if (collision.CompareTag("Tower"))
        {
            _towers.Add(collision.gameObject);
        }

        else if (collision.CompareTag("Base"))
        {
            _baseTarget = collision.gameObject;
        }
    }
    void OnTriggerExit(Collider collision)
    {
        if (collision.CompareTag("Tower"))
        {
            _towers.Remove(collision.gameObject);
        }
        else if (collision.CompareTag("Base"))
        {
            _baseTarget = null;
        }
    }
    public void IncreaseDamageScaling()
    {
        _damageScaling += (int)math.round(malwareData.AttackDamage * .1f);
        UpdateMalwareDamage();
    }
    private void UpdateMalwareDamage()
    {
        _damage = malwareData.AttackDamage + _damageScaling;
        
    }
    private IEnumerator IncreaseDamageScalingPeriodically(float interval)
    {
        while (true)
        {
            yield return new WaitForSeconds(interval);
            IncreaseDamageScaling();
        }
    }
}
